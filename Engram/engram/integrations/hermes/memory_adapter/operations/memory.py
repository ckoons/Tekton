"""
Memory operations for the Hermes Memory Adapter.

This module provides functions for adding, clearing, and managing memories.
"""

from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Union

from ..core.imports import logger, HAS_HERMES
from ..utils.helpers import format_conversation, generate_memory_id, validate_namespace


async def add_memory(hermes_client, fallback_storage, compartment_manager,
                    content: Union[str, List[Dict[str, str]]], 
                    namespace: str = "conversations",
                    metadata: Optional[Dict[str, Any]] = None,
                    client_id: str = "default") -> bool:
    """
    Add a memory to storage.
    
    Args:
        hermes_client: Hermes database client
        fallback_storage: Fallback storage implementation
        compartment_manager: Compartment manager
        content: Memory content
        namespace: Namespace to store in
        metadata: Optional metadata
        client_id: Client identifier
        
    Returns:
        True if successful, False otherwise
    """
    # Validate namespace
    valid_namespaces = ["conversations", "thinking", "longterm", "projects", "compartments", "session"]
    namespace = validate_namespace(namespace, valid_namespaces, compartment_manager.compartments)
    
    # Get current timestamp
    timestamp = datetime.now().isoformat()
    
    # Prepare metadata
    if metadata is None:
        metadata = {}
    
    metadata["timestamp"] = timestamp
    metadata["client_id"] = client_id
    
    # Format content
    content_str = format_conversation(content)
    
    # Generate memory ID
    memory_id = generate_memory_id(namespace, content_str)
    metadata["id"] = memory_id
    
    # Store using Hermes if available
    if HAS_HERMES and hermes_client:
        try:
            # Get vector database
            vector_db = await hermes_client.get_vector_db(namespace=namespace)
            
            # Store the memory with its metadata
            result = await vector_db.store(
                id=memory_id,
                vector=None,  # Vector will be generated by the embedding model
                metadata=metadata,
                text=content_str
            )
            
            logger.debug(f"Added memory to Hermes vector database in namespace {namespace}")
            return result
        except Exception as e:
            logger.error(f"Error adding memory to Hermes: {e}")
            # Fall back to local storage
    
    # Store in fallback memory
    return fallback_storage.add_memory(memory_id, content_str, namespace, metadata)


async def clear_namespace(hermes_client, fallback_storage, compartment_manager,
                         namespace: str) -> bool:
    """
    Clear all memories in a namespace.
    
    Args:
        hermes_client: Hermes database client
        fallback_storage: Fallback storage implementation
        compartment_manager: Compartment manager
        namespace: Namespace to clear
        
    Returns:
        True if successful, False otherwise
    """
    valid_namespaces = ["conversations", "thinking", "longterm", "projects", "compartments", "session"]
    
    # Support compartment namespaces
    if namespace.startswith("compartment-"):
        compartment_id = namespace[len("compartment-"):]
        if compartment_id not in compartment_manager.compartments:
            logger.warning(f"Invalid compartment: {compartment_id}")
            return False
    elif namespace not in valid_namespaces:
        logger.warning(f"Invalid namespace: {namespace}")
        return False
    
    # Clear Hermes storage if available
    if HAS_HERMES and hermes_client:
        try:
            # Delete all documents in the namespace
            vector_db = await hermes_client.get_vector_db(namespace=namespace)
            await vector_db.delete()  # Delete all vectors in this namespace
            
            logger.info(f"Cleared namespace {namespace} in Hermes storage")
            return True
        except Exception as e:
            logger.error(f"Error clearing namespace in Hermes storage: {e}")
            # Fall back to basic storage
    
    # Clear fallback memory
    return fallback_storage.clear_namespace(namespace)


async def write_session_memory(hermes_client, fallback_storage, compartment_manager,
                              content: str, 
                              metadata: Optional[Dict[str, Any]] = None,
                              client_id: str = "default") -> bool:
    """
    Write a memory to the session namespace.
    
    Args:
        hermes_client: Hermes database client
        fallback_storage: Fallback storage implementation
        compartment_manager: Compartment manager
        content: Memory content
        metadata: Optional metadata
        client_id: Client identifier
        
    Returns:
        True if successful, False otherwise
    """
    try:
        # Add to session namespace
        return await add_memory(
            hermes_client, fallback_storage, compartment_manager,
            content=content, namespace="session", 
            metadata=metadata, client_id=client_id
        )
    except Exception as e:
        logger.error(f"Error writing session memory: {e}")
        return False


async def keep_memory(hermes_client, fallback_storage, memory_id: str, days: int = 30) -> bool:
    """
    Keep a memory for a specified number of days.
    
    Args:
        hermes_client: Hermes database client
        fallback_storage: Fallback storage implementation
        memory_id: Memory ID
        days: Number of days to keep
        
    Returns:
        True if successful, False otherwise
    """
    # For Hermes storage, we would need to update metadata
    # This is best done with a document database, which is not yet implemented
    # For now, only implement fallback support
    return await fallback_storage.keep_memory(memory_id, days)