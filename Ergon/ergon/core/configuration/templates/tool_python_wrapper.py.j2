#!/usr/bin/env python
"""
Wrapper for the {{ tool.name }} tool.

Generated by Ergon on {{ now().strftime('%Y-%m-%d') }}
"""

import sys
import os
import logging
from typing import Dict, List, Optional, Any, Union
import json
import argparse

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('{{ tool.name }}_wrapper')

# Tool metadata
TOOL_INFO = {
    "name": "{{ tool.name }}",
    "description": """{{ tool.description }}""",
    "version": "{{ tool.version }}",
    "entry_point": "{{ tool.entry_point }}",
    "implementation_type": "{{ tool.implementation_type }}"
}

# Tool parameters
PARAMETERS = {{ tool_parameters|tojson }}

# User-provided parameters
USER_PARAMS = {{ params|tojson }}


def main():
    """Execute the tool with the configured parameters."""
    parser = argparse.ArgumentParser(description=TOOL_INFO["description"])
    parser.add_argument('--show-config', action='store_true', help='Show the current configuration')
    parser.add_argument('--param', action='append', nargs=2, metavar=('NAME', 'VALUE'), 
                        help='Override a parameter (can be used multiple times)')
    
    args = parser.parse_args()
    
    # If show-config, display the configuration and exit
    if args.show_config:
        print(f"Tool: {TOOL_INFO['name']} (v{TOOL_INFO['version']})")
        print(f"Description: {TOOL_INFO['description']}")
        print("\nParameters:")
        for name, param in PARAMETERS.items():
            value = USER_PARAMS.get(name, param.get('default_value', 'None'))
            print(f"  {name}: {value}")
            print(f"    Description: {param['description']}")
            print(f"    Type: {param['type']}")
            print(f"    Required: {param['required']}")
        return
    
    # Start with the configured parameters
    final_params = USER_PARAMS.copy()
    
    # Override with command-line parameters if provided
    if args.param:
        for name, value in args.param:
            # Try to parse the value based on the parameter type
            parsed_value = parse_value(value, PARAMETERS.get(name, {}).get('type', 'string'))
            final_params[name] = parsed_value
    
    try:
        # Import the module dynamically
        module_path = TOOL_INFO["entry_point"].split(".")
        module_name = ".".join(module_path[:-1])
        function_name = module_path[-1]
        
        logger.info(f"Importing {module_name}")
        module = __import__(module_name, fromlist=[function_name])
        function = getattr(module, function_name)
        
        # Call the function with the parameters
        logger.info(f"Executing {TOOL_INFO['entry_point']} with parameters: {final_params}")
        result = function(**final_params)
        
        # Print the result
        print(json.dumps(result, indent=2, default=str))
        
    except ImportError as e:
        logger.error(f"Failed to import {TOOL_INFO['entry_point']}: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Error executing tool: {e}")
        sys.exit(1)


def parse_value(value: str, param_type: str) -> Any:
    """Parse a string value based on the parameter type.
    
    Args:
        value: String value to parse
        param_type: Type to parse as
        
    Returns:
        Parsed value
    """
    if param_type == 'string':
        return value
    elif param_type == 'integer':
        return int(value)
    elif param_type == 'float':
        return float(value)
    elif param_type == 'boolean':
        return value.lower() in ('true', 'yes', '1', 'y')
    elif param_type == 'array':
        return json.loads(value)
    elif param_type == 'object':
        return json.loads(value)
    else:
        return value


if __name__ == "__main__":
    main()