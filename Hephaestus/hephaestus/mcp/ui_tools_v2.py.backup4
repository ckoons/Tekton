"""
UI DevTools MCP v2 - Fixed to properly work with Hephaestus UI

IMPORTANT: This version correctly targets the Hephaestus UI at port 8080
and understands that all components are rendered within that single UI.
"""

import asyncio
import json
import os
import re
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple, Union
from urllib.parse import urlparse

from playwright.async_api import async_playwright, Browser, BrowserContext, Page
from bs4 import BeautifulSoup, NavigableString, Tag
import lxml.html
from cssselect import GenericTranslator

# Import configuration properly
from shared.utils.global_config import GlobalConfig
from shared.utils.logging_setup import setup_component_logging

# Import constants and exceptions
from .constants import (
    HEPHAESTUS_PORT, HEPHAESTUS_URL, UI_COMPONENTS, DANGEROUS_PATTERNS,
    UIToolsError, ComponentNotFoundError, FrameworkDetectedError
)

# Import browser manager
from .browser_manager import browser_manager

# Import HTML processing functions
from .html_processor import (
    detect_dangerous_patterns,
    extract_element_info,
    suggest_similar_selectors,
    count_elements_in_tree,
    html_to_structured_data,
    analyze_dynamic_content
)

# Import navigation functions
from .navigation_tools import (
    find_component_element,
    ui_navigate
)

# Import capture functions
from .capture_tools import ui_capture

# Initialize logger
logger = setup_component_logging("ui_devtools")





def list_ui_areas() -> Dict[str, Any]:
    """List all available UI areas and their descriptions"""
    return {
        "ui_url": HEPHAESTUS_URL,
        "areas": {
            name: {
                "description": info["description"],
                "example_selectors": info["selectors"][:2]  # Show first 2 examples
            }
            for name, info in UI_COMPONENTS.items()
        },
        "note": "All areas are within the main Hephaestus UI at port 8080"
    }










async def ui_list_areas() -> Dict[str, Any]:
    """
    List all available UI areas in Hephaestus
    
    Returns:
        Information about available UI areas and how to use them
    """
    return list_ui_areas()


async def ui_recommend_approach(
    target_description: str,
    intended_change: str,
    area: str = "hephaestus"
) -> Dict[str, Any]:
    """
    Phase 1: Analyze request and recommend optimal tool path with confidence scoring
    
    Args:
        target_description: Description of what you want to modify (e.g., "chat interface", "navigation button")
        intended_change: What you want to do (e.g., "add semantic tags", "change text", "add element")
        area: UI area to work in
    
    Returns:
        Recommendation with reasoning and specific guidance
    """
    await browser_manager.initialize()
    page = await browser_manager.get_page()
    
    result = {
        "target": target_description,
        "change": intended_change,
        "area": area,
        "recommended_tool": "devtools",
        "confidence": 0.0,
        "reasoning": "",
        "specific_guidance": "",
        "fallback_strategy": "",
        "file_locations": []
    }
    
    # Capture current area to analyze
    try:
        capture_result = await ui_capture(area=area)
        dynamic_analysis = capture_result.get("dynamic_analysis", {})
    except Exception as e:
        result["recommended_tool"] = "file_editing"
        result["confidence"] = 0.9
        result["reasoning"] = f"Could not access UI area '{area}': {str(e)}. File editing is safer."
        result["specific_guidance"] = f"Edit the {area}-component.html file directly"
        return result
    
    # Analyze the request
    target_lower = target_description.lower()
    change_lower = intended_change.lower()
    
    # Pattern matching for common scenarios
    dynamic_keywords = ["chat", "form", "input", "panel", "content", "interface", "workspace"]
    navigation_keywords = ["nav", "button", "link", "menu", "header", "footer"]
    semantic_keywords = ["semantic", "tag", "attribute", "data-tekton"]
    
    # Check if target involves dynamic content
    involves_dynamic = any(keyword in target_lower for keyword in dynamic_keywords)
    involves_navigation = any(keyword in target_lower for keyword in navigation_keywords)
    involves_semantics = any(keyword in change_lower for keyword in semantic_keywords)
    
    # Factor in dynamic analysis
    content_type = dynamic_analysis.get("content_type", "static")
    dynamic_areas = dynamic_analysis.get("dynamic_areas", [])
    
    # Decision logic
    if content_type == "static" and not involves_dynamic:
        # Static content, safe for DevTools
        result["recommended_tool"] = "devtools"
        result["confidence"] = 0.95
        result["reasoning"] = "Static content area with no dynamic loading detected. DevTools are ideal."
        result["specific_guidance"] = f"Use ui_sandbox with area='{area}' and appropriate selectors"
    
    elif involves_navigation and not involves_dynamic:
        # Navigation elements, usually safe for DevTools
        result["recommended_tool"] = "devtools"
        result["confidence"] = 0.9
        result["reasoning"] = "Navigation elements are typically static and well-suited for DevTools"
        result["specific_guidance"] = "Target navigation elements with selectors like .nav-label or [data-tekton-nav]"
    
    elif involves_dynamic or content_type == "dynamic":
        # Dynamic content, recommend file editing
        result["recommended_tool"] = "file_editing"
        result["confidence"] = 0.85
        result["reasoning"] = "Target involves dynamic content areas that DevTools cannot see reliably"
        result["specific_guidance"] = f"Edit {area}-component.html directly for component interior content"
        
        # Add specific file locations if available
        if dynamic_areas:
            for da in dynamic_areas:
                if area in da.get("file_location", ""):
                    result["file_locations"].append(da["file_location"])
    
    elif content_type == "hybrid":
        # Hybrid content, depends on specific target
        if involves_navigation or involves_semantics:
            result["recommended_tool"] = "devtools"
            result["confidence"] = 0.75
            result["reasoning"] = "Hybrid content but targeting navigation/semantic elements that DevTools can handle"
            result["specific_guidance"] = "Try DevTools first, fall back to file editing if elements not found"
        else:
            result["recommended_tool"] = "file_editing"
            result["confidence"] = 0.8
            result["reasoning"] = "Hybrid content and target description suggests component interior work"
            result["specific_guidance"] = f"Edit {area}-component.html for better access to component internals"
    
    else:
        # Default fallback
        result["recommended_tool"] = "devtools"
        result["confidence"] = 0.6
        result["reasoning"] = "Default recommendation - try DevTools first as it's safer"
        result["specific_guidance"] = "Start with DevTools, switch to file editing if needed"
    
    # Build fallback strategy
    if result["recommended_tool"] == "devtools":
        result["fallback_strategy"] = f"If DevTools fails to find elements, try file editing {area}-component.html"
    else:
        result["fallback_strategy"] = f"If file editing is too complex, try DevTools with area='{area}' first"
    
    # Add file locations if not already specified
    if not result["file_locations"] and area != "hephaestus":
        result["file_locations"] = [f"{area}-component.html"]
    
    # Time estimates
    if result["recommended_tool"] == "devtools":
        result["time_estimate"] = "~30 seconds with DevTools, ~5 minutes with file editing"
    else:
        result["time_estimate"] = "~5 minutes with file editing, DevTools may not work"
    
    return result


async def ui_capture(
    area: str = "hephaestus",
    selector: Optional[str] = None,
    include_screenshot: bool = False
) -> Dict[str, Any]:
    """
    Capture UI state from Hephaestus UI with enhanced dynamic content detection
    
    Args:
        area: UI area name (e.g., 'rhetor', 'navigation', 'content')
              Use 'hephaestus' for the entire UI
        selector: Optional CSS selector for specific element within the area
        include_screenshot: Whether to include a visual screenshot
    
    Returns:
        Structured data about the UI state with dynamic content analysis
    """
    await browser_manager.initialize()
    page = await browser_manager.get_page()
    
    result = {
        "area": area,
        "ui_url": HEPHAESTUS_URL,
        "title": await page.title(),
        "current_url": page.url,
        "viewport": page.viewport_size,
    }
    
    # Detect current component state (ignoring unreliable nav state)
    component_state = await page.evaluate("""
        () => {
            // Find loaded component in content area - this is what matters
            let loadedComponent = null;
            const contentArea = document.querySelector('[data-tekton-area="content"], .main-content, #center-content');
            if (contentArea) {
                // Look for component indicators in content
                const componentElement = contentArea.querySelector('[data-tekton-area], [data-tekton-component], [data-component]');
                if (componentElement) {
                    loadedComponent = componentElement.getAttribute('data-tekton-area') || 
                                    componentElement.getAttribute('data-tekton-component') ||
                                    componentElement.getAttribute('data-component');
                } else {
                    // Try to detect by class name
                    const divWithClass = contentArea.querySelector('div[class*="__"]');
                    if (divWithClass) {
                        const className = divWithClass.className;
                        const match = className.match(/^(\\w+)__/);
                        if (match) {
                            loadedComponent = match[1];
                        }
                    }
                }
            }
            
            // Check if we're in a special view (settings, profile)
            const specialViews = ['settings', 'profile'];
            let currentView = null;
            for (const view of specialViews) {
                if (document.querySelector(`.${view}__container, #${view}-container, [data-component="${view}"]`)) {
                    currentView = view;
                    break;
                }
            }
            
            return {
                loaded_component: loadedComponent || currentView,
                detection_method: loadedComponent ? 'data-attribute' : (currentView ? 'special-view' : 'none')
            };
        }
    """)
    
    # Add component state to result
    result["loaded_component"] = component_state["loaded_component"]
    
    # What really matters is what's loaded
    if component_state["loaded_component"]:
        result["working_with"] = component_state["loaded_component"]
    
    # Get HTML content for the specified area
    if area == "hephaestus":
        # Capture entire UI
        html = await page.content()
        result["description"] = "Entire Hephaestus UI"
    else:
        # Find the component area
        try:
            element = await find_component_element(page, area)
            html = await element.inner_html()
            result["description"] = UI_COMPONENTS[area]["description"]
            result["found_with_selector"] = await element.evaluate("el => el.tagName + (el.id ? '#' + el.id : '') + (el.className ? '.' + el.className.split(' ').join('.') : '')")
        except ComponentNotFoundError as e:
            result["error"] = str(e)
            result["available_areas"] = list(UI_COMPONENTS.keys())
            return result
    
    # Apply additional selector if provided
    if selector:
        result["selector"] = selector
        # Parse the HTML we already have instead of waiting for selector on page
        # This is more reliable and works with the area concept
    
    # Add raw HTML to result for better debugging and searching
    result["html"] = html
    result["html_length"] = len(html)
    
    # Convert to structured data
    result["structure"] = html_to_structured_data(html, selector)
    
    # Parse HTML once for all operations
    soup = BeautifulSoup(html, 'html.parser')
    
    # Add common selector counts for quick reference
    result["selectors_available"] = {
        ".nav-label": len(soup.select(".nav-label")),
        "[data-component]": len(soup.select("[data-component]")),
        "[data-tekton-nav]": len(soup.select("[data-tekton-nav]")),
        "[data-tekton-area]": len(soup.select("[data-tekton-area]")),
        "button": len(soup.select("button")),
        "input": len(soup.select("input")),
        "form": len(soup.select("form")),
        "a": len(soup.select("a"))
    }
    
    # If selector was not found, add the suggestions to the main result for visibility
    if result["structure"].get("selector_not_found"):
        result["selector_error"] = result["structure"]["suggestion_message"]
        result["suggestions"] = result["structure"]["suggestions"]
        # Return early since there's no point extracting forms/buttons/etc from non-existent elements
        return result
    
    # Extract forms
    forms = soup.find_all("form")
    if forms:
        result["forms"] = []
        for form in forms:
            form_data = {
                "id": form.get("id"),
                "action": form.get("action"),
                "method": form.get("method"),
                "inputs": []
            }
            
            inputs = form.find_all(["input", "select", "textarea"])
            for input_el in inputs:
                input_data = {
                    "type": input_el.get("type", "text"),
                    "name": input_el.get("name"),
                    "id": input_el.get("id"),
                    "value": input_el.get("value"),
                    "placeholder": input_el.get("placeholder")
                }
                form_data["inputs"].append(input_data)
            
            result["forms"].append(form_data)
    
    # Extract buttons
    buttons = soup.find_all(["button", "input[type='button']", "input[type='submit']"])
    if buttons:
        result["buttons"] = []
        for button in buttons[:20]:  # Limit to 20
            text = button.get_text(strip=True) if hasattr(button, 'get_text') else button.get("value", "")
            result["buttons"].append({
                "text": text,
                "id": button.get("id"),
                "classes": " ".join(button.get("class", [])) if button.get("class") else None,
                "onclick": button.get("onclick")
            })
    
    # Extract links
    links = soup.find_all("a", href=True)
    if links:
        result["links"] = []
        for link in links[:20]:  # Limit to 20
            result["links"].append({
                "href": link.get("href"),
                "text": link.get_text(strip=True),
                "id": link.get("id")
            })
    
    # PHASE 1 ENHANCEMENT: Dynamic Content Analysis
    result["dynamic_analysis"] = await analyze_dynamic_content(page, area, html)
    
    # Include screenshot if requested
    if include_screenshot:
        screenshot = await page.screenshot(full_page=False)
        result["screenshot"] = {
            "type": "base64",
            "data": screenshot.hex()
        }
    
    return result


async def ui_interact(
    area: str,
    action: str,
    selector: str,
    value: Optional[str] = None,
    capture_changes: bool = True
) -> Dict[str, Any]:
    """
    Interact with UI elements in Hephaestus
    
    Args:
        area: UI area name (use 'hephaestus' for general interactions)
        action: Type of action ('click', 'type', 'select', 'hover')
        selector: CSS selector for the element
        value: Value for type/select actions
        capture_changes: Whether to capture before/after state
    
    Returns:
        Result of the interaction including any changes
    """
    await browser_manager.initialize()
    page = await browser_manager.get_page()
    
    result = {
        "area": area,
        "action": action,
        "selector": selector,
        "value": value
    }
    
    # Navigate to component area first if specified
    if area != "hephaestus":
        try:
            await find_component_element(page, area)
        except ComponentNotFoundError as e:
            result["error"] = str(e)
            return result
    
    # Capture before state
    if capture_changes:
        before_html = await page.content()
        result["before"] = html_to_structured_data(before_html)
    
    # Set up monitoring
    console_messages = []
    network_requests = []
    
    async def handle_console(msg):
        console_messages.append({
            "type": msg.type,
            "text": msg.text
        })
    
    async def handle_request(request):
        if request.resource_type in ["xhr", "fetch"]:
            network_requests.append({
                "url": request.url,
                "method": request.method
            })
    
    page.on("console", handle_console)
    page.on("request", handle_request)
    
    try:
        # Wait for element
        element = await page.wait_for_selector(selector, timeout=5000)
        
        # Perform action
        if action == "click":
            await element.click()
            await page.wait_for_load_state("networkidle", timeout=5000)
        
        elif action == "type":
            if value is None:
                raise ValueError("Value required for type action")
            await element.clear()
            await element.type(value)
        
        elif action == "select":
            if value is None:
                raise ValueError("Value required for select action")
            await element.select_option(value)
        
        elif action == "hover":
            await element.hover()
            await asyncio.sleep(0.5)
        
        else:
            raise ValueError(f"Unknown action: {action}")
        
        result["success"] = True
        
        # Capture after state
        if capture_changes:
            after_html = await page.content()
            result["after"] = html_to_structured_data(after_html)
            
            # Simple change detection
            changes = []
            if len(before_html) != len(after_html):
                changes.append("Page content changed")
            
            if console_messages:
                changes.append(f"{len(console_messages)} console messages")
            
            if network_requests:
                changes.append(f"{len(network_requests)} network requests")
            
            result["changes"] = changes
        
        # Add console and network activity
        if console_messages:
            result["console"] = console_messages
        if network_requests:
            result["network"] = network_requests
    
    except Exception as e:
        result["success"] = False
        result["error"] = str(e)
    
    finally:
        page.remove_listener("console", handle_console)
        page.remove_listener("request", handle_request)
    
    return result


async def ui_sandbox(
    area: str,
    changes: List[Dict[str, Any]],
    preview: bool = True
) -> Dict[str, Any]:
    """
    Test UI changes in a sandboxed environment
    
    Args:
        area: UI area to modify (use 'hephaestus' for general changes)
        changes: List of changes to apply
        preview: Whether to preview changes without applying
    
    Returns:
        Result of sandbox testing including validation
    """
    await browser_manager.initialize()
    page = await browser_manager.get_page()
    
    result = {
        "area": area,
        "changes": changes,
        "preview": preview,
        "validations": []
    }
    
    # Validate changes for dangerous patterns
    for i, change in enumerate(changes):
        change_content = change.get("content", "")
        detected = detect_dangerous_patterns(change_content)
        
        if detected:
            result["validations"].append({
                "change_index": i,
                "status": "rejected",
                "reason": "Dangerous patterns detected",
                "patterns": detected
            })
            
            result["applied"] = False
            result["error"] = "Changes rejected due to framework/complexity detection"
            return result
    
    # Create snapshot
    original_html = await page.content()
    result["original_snapshot"] = html_to_structured_data(original_html)
    
    # Apply changes
    sandbox_results = []
    
    for i, change in enumerate(changes):
        change_type = change.get("type", "html")
        selector = change.get("selector")
        content = change.get("content", "")
        action = change.get("action", "replace")
        
        try:
            if change_type in ["html", "text"]:
                # Escape content and selector properly
                escaped_content = content.replace('\\', '\\\\').replace('`', '\\`').replace('${', '\\${')
                escaped_selector = selector.replace('\\', '\\\\').replace("'", "\\'")
                
                js_code = f"""
                (function() {{
                    const elements = document.querySelectorAll('{escaped_selector}');
                    if (elements.length === 0) {{
                        // Enhanced error message with file editing guidance
                        return {{ 
                            success: false, 
                            error: 'No elements found for selector: {escaped_selector}',
                            guidance: 'Element not visible to DevTools - try file editing: {area}-component.html'
                        }};
                    }}
                    
                    elements.forEach(el => {{
                        const content = `{escaped_content}`;
                        
                        switch('{action}') {{
                            case 'replace':
                                {f'el.textContent = content;' if change_type == 'text' else 'el.innerHTML = content;'}
                                break;
                            case 'append':
                                {f'el.textContent += content;' if change_type == 'text' else 'el.innerHTML += content;'}
                                break;
                            case 'prepend':
                                {f'el.textContent = content + el.textContent;' if change_type == 'text' else 'el.innerHTML = content + el.innerHTML;'}
                                break;
                            case 'after':
                                el.insertAdjacentHTML('afterend', {'`<span>${content}</span>`' if change_type == 'text' else 'content'});
                                break;
                            case 'before':
                                el.insertAdjacentHTML('beforebegin', {'`<span>${content}</span>`' if change_type == 'text' else 'content'});
                                break;
                        }}
                    }});
                    
                    return {{ success: true, count: elements.length }};
                }})();
                """
                
                result_js = await page.evaluate(js_code)
                sandbox_results.append({
                    "change_index": i,
                    "success": result_js.get("success", False),
                    "elements_modified": result_js.get("count", 0),
                    "error": result_js.get("error"),
                    "guidance": result_js.get("guidance")  # Phase 1: Enhanced error guidance
                })
            
            elif change_type == "css":
                # Support both full CSS rules and single property changes
                if "property" in change and "value" in change:
                    # Single property format
                    css_rule = f"{selector} {{ {change['property']}: {change['value']}; }}"
                else:
                    # Full CSS content
                    css_rule = content
                
                await page.add_style_tag(content=css_rule)
                sandbox_results.append({
                    "change_index": i,
                    "success": True,
                    "type": "css_injected",
                    "css": css_rule
                })
            
            elif change_type == "js":
                if detect_dangerous_patterns(content):
                    sandbox_results.append({
                        "change_index": i,
                        "success": False,
                        "error": "JavaScript contains framework/build tool references"
                    })
                else:
                    await page.evaluate(content)
                    sandbox_results.append({
                        "change_index": i,
                        "success": True,
                        "type": "js_executed"
                    })
        
        except Exception as e:
            sandbox_results.append({
                "change_index": i,
                "success": False,
                "error": str(e)
            })
    
    result["sandbox_results"] = sandbox_results
    
    # Capture final state
    final_html = await page.content()
    result["final_snapshot"] = html_to_structured_data(final_html)
    
    # If preview mode, restore
    if preview:
        await page.set_content(original_html)
        result["restored"] = True
    else:
        result["applied"] = True
    
    # Summary
    successful = sum(1 for r in sandbox_results if r.get("success", False))
    result["summary"] = {
        "total_changes": len(changes),
        "successful": successful,
        "failed": len(changes) - successful
    }
    
    return result


async def ui_analyze(
    area: str = "hephaestus",
    deep_scan: bool = False
) -> Dict[str, Any]:
    """
    Analyze UI structure and patterns
    
    Args:
        area: UI area to analyze
        deep_scan: Whether to perform deep analysis
    
    Returns:
        Analysis of UI structure, patterns, and recommendations
    """
    await browser_manager.initialize()
    page = await browser_manager.get_page()
    
    result = {
        "area": area,
        "ui_url": HEPHAESTUS_URL,
        "analysis": {}
    }
    
    # Get HTML for the area
    if area == "hephaestus":
        html = await page.content()
    else:
        try:
            element = await find_component_element(page, area)
            html = await element.inner_html()
        except ComponentNotFoundError as e:
            result["error"] = str(e)
            return result
    
    soup = BeautifulSoup(html, 'html.parser')
    
    # Analyze structure
    structure_analysis = {
        "total_elements": len(soup.find_all()),
        "forms": len(soup.find_all("form")),
        "inputs": len(soup.find_all(["input", "textarea", "select"])),
        "buttons": len(soup.find_all(["button", "input[type='button']", "input[type='submit']"])),
        "links": len(soup.find_all("a")),
        "images": len(soup.find_all("img")),
        "tables": len(soup.find_all("table")),
        "divs": len(soup.find_all("div")),
        "sections": len(soup.find_all(["section", "article", "aside", "nav", "header", "footer"]))
    }
    result["analysis"]["structure"] = structure_analysis
    
    # Detect frameworks and libraries
    framework_detection = {
        "react": False,
        "vue": False,
        "angular": False,
        "jquery": False,
        "bootstrap": False,
        "tailwind": False
    }
    
    # Check for framework indicators
    scripts = soup.find_all("script")
    for script in scripts:
        src = script.get("src", "")
        text = script.string or ""
        
        if "react" in src.lower() or "React" in text:
            framework_detection["react"] = True
        if "vue" in src.lower() or "Vue" in text:
            framework_detection["vue"] = True
        if "angular" in src.lower() or "angular" in text:
            framework_detection["angular"] = True
        if "jquery" in src.lower() or "$(" in text or "jQuery" in text:
            framework_detection["jquery"] = True
    
    result["analysis"]["frameworks"] = framework_detection
    
    # Component-specific insights
    if area != "hephaestus":
        component_info = {
            "area_name": area,
            "description": UI_COMPONENTS[area]["description"],
            "suggested_selectors": UI_COMPONENTS[area]["selectors"],
            "found": True
        }
        result["analysis"]["component_info"] = component_info
    
    # Complexity assessment
    complexity_score = 0
    complexity_factors = []
    
    if any(framework_detection.values()):
        complexity_score += 10
        complexity_factors.append("Frameworks detected")
    
    if structure_analysis["total_elements"] > 1000:
        complexity_score += 2
        complexity_factors.append(f"Large DOM ({structure_analysis['total_elements']} elements)")
    
    result["analysis"]["complexity"] = {
        "score": complexity_score,
        "level": "high" if complexity_score >= 10 else "medium" if complexity_score >= 5 else "low",
        "factors": complexity_factors
    }
    
    # Recommendations
    recommendations = []
    
    if any(framework_detection.values()):
        recommendations.append({
            "type": "warning",
            "message": "Frameworks detected. Avoid adding more complexity.",
            "frameworks": [k for k, v in framework_detection.items() if v]
        })
    
    recommendations.append({
        "type": "info",
        "message": f"Working in '{area}' area. Use selectors like: {', '.join(UI_COMPONENTS.get(area, {}).get('selectors', [])[:2])}"
    })
    
    result["recommendations"] = recommendations
    
    return result


async def ui_validate(
    scope: str = "current",
    checks: Optional[List[str]] = None,
    detailed: bool = False
) -> Dict[str, Any]:
    """
    Validate UI instrumentation and semantic tagging
    
    Args:
        scope: 'current' (loaded component), 'navigation', or 'all' (all components)
        checks: List of specific checks to run (defaults to all)
        detailed: Whether to include detailed findings
        
    Returns:
        Validation report with coverage metrics and recommendations
    """
    await browser_manager.initialize()
    page = await browser_manager.get_page()
    
    # Default checks if none specified
    if checks is None:
        checks = ["semantic-tags", "navigation", "data-attributes", "component-structure"]
    
    result = {
        "scope": scope,
        "timestamp": datetime.now().isoformat(),
        "checks_performed": checks,
        "summary": {},
        "findings": [],
        "recommendations": []
    }
    
    # Get current component state (only trust loaded component)
    component_state = await page.evaluate("""
        () => {
            // Find loaded component in content area - this is what matters
            let loadedComponent = null;
            const contentArea = document.querySelector('[data-tekton-area="content"], .main-content, #center-content');
            if (contentArea) {
                // Look for component indicators in content
                const componentElement = contentArea.querySelector('[data-tekton-area], [data-tekton-component], [data-component]');
                if (componentElement) {
                    loadedComponent = componentElement.getAttribute('data-tekton-area') || 
                                    componentElement.getAttribute('data-tekton-component') ||
                                    componentElement.getAttribute('data-component');
                } else {
                    // Try to detect by class name
                    const divWithClass = contentArea.querySelector('div[class*="__"]');
                    if (divWithClass) {
                        const className = divWithClass.className;
                        const match = className.match(/^(\\w+)__/);
                        if (match) {
                            loadedComponent = match[1];
                        }
                    }
                }
            }
            
            return { 
                loadedComponent: loadedComponent || 'unknown',
                hasContentArea: !!contentArea 
            };
        }
    """)
    
    # Validate based on scope
    if scope == "current":
        # Validate currently loaded component
        if not component_state["loadedComponent"] or component_state["loadedComponent"] == "unknown":
            result["error"] = "No component currently loaded"
            return result
            
        validation = await _validate_component(page, component_state["loadedComponent"], checks)
        result["component"] = component_state["loadedComponent"]
        result["summary"] = validation["summary"]
        result["findings"] = validation["findings"]
        result["recommendations"] = validation["recommendations"]
        
    elif scope == "navigation":
        # Validate navigation structure
        nav_validation = await _validate_navigation(page, checks)
        result["summary"] = nav_validation["summary"]
        result["findings"] = nav_validation["findings"]
        result["recommendations"] = nav_validation["recommendations"]
        
    elif scope == "all":
        # Get all components from navigation
        all_components = await page.evaluate("""
            () => {
                const navItems = document.querySelectorAll('.nav-item[data-component]');
                return Array.from(navItems).map(item => item.getAttribute('data-component'));
            }
        """)
        
        result["components_checked"] = []
        result["progress"] = []
        total_score = 0
        
        # Log start
        logger.info(f"Starting validation of {len(all_components)} components")
        
        # Skip certain utility components if desired
        skip_components = ['settings', 'profile']  # Can be made configurable
        
        for idx, component in enumerate(all_components):
            if component in skip_components:
                logger.info(f"Skipping utility component: {component}")
                continue
                
            progress_msg = f"Validating {component} ({idx+1}/{len(all_components)})"
            logger.info(progress_msg)
            result["progress"].append({
                "component": component,
                "status": "started",
                "timestamp": datetime.now().isoformat()
            })
            
            try:
                # Navigate to component with shorter timeout
                nav_result = await ui_navigate(component, wait_for_load=True, timeout=2000)
                
                if nav_result.get("navigation_completed"):
                    # Navigation worked - trust it and validate the component
                    validation = await _validate_component(page, component, checks)
                    
                    component_result = {
                        "component": component,
                        "score": validation["summary"].get("score", 0),
                        "issues": len(validation["findings"])
                    }
                    
                    if detailed:
                        component_result["findings"] = validation["findings"]
                    
                    result["components_checked"].append(component_result)
                    total_score += component_result["score"]
                    
                    result["progress"][-1]["status"] = "completed"
                else:
                    result["progress"][-1]["status"] = "navigation_failed"
                    logger.warning(f"Failed to navigate to {component}")
                    
            except asyncio.TimeoutError:
                result["progress"][-1]["status"] = "timeout"
                logger.warning(f"Timeout navigating to {component}")
            except Exception as e:
                result["progress"][-1]["status"] = "error"
                result["progress"][-1]["error"] = str(e)
                logger.error(f"Error validating {component}: {e}")
        
        # Calculate overall score
        if result["components_checked"]:
            result["summary"]["overall_score"] = total_score / len(result["components_checked"])
            result["summary"]["components_validated"] = len(result["components_checked"])
            result["summary"]["total_issues"] = sum(c["issues"] for c in result["components_checked"])
            result["summary"]["components_attempted"] = len(all_components)
            result["summary"]["validation_time"] = f"{(datetime.now() - datetime.fromisoformat(result['timestamp'])).total_seconds():.1f}s"
    
    # Add general recommendations based on findings
    if result["findings"] or (scope == "all" and result["summary"].get("total_issues", 0) > 0):
        result["recommendations"].append({
            "priority": "high",
            "message": "Review and add missing semantic tags using the instrumentation template"
        })
    
    return result


async def _validate_component(page: Page, component: str, checks: List[str]) -> Dict[str, Any]:
    """Validate a single component's instrumentation"""
    validation = {
        "summary": {"score": 100},
        "findings": [],
        "recommendations": []
    }
    
    # Check if component is loaded
    component_html = await page.evaluate(f"""
        () => {{
            const component = document.querySelector('[data-tekton-area="{component}"], [data-tekton-component="{component}"], .{component}');
            return component ? component.outerHTML : null;
        }}
    """)
    
    if not component_html:
        validation["findings"].append({
            "type": "error",
            "check": "component-presence",
            "message": f"Component '{component}' not found in DOM"
        })
        validation["summary"]["score"] = 0
        return validation
    
    # Parse component HTML
    soup = BeautifulSoup(component_html, 'html.parser')
    root = soup.find()
    
    # Check semantic tags
    if "semantic-tags" in checks:
        semantic_score = 100
        
        # Check root has data-tekton-area
        if not root.get("data-tekton-area"):
            validation["findings"].append({
                "type": "missing",
                "check": "semantic-tags",
                "element": "root",
                "message": f"Root element missing data-tekton-area=\"{component}\""
            })
            semantic_score -= 20
        
        # Check for zone tags
        zones = ["header", "menu", "content", "footer"]
        for zone in zones:
            zone_element = soup.find(attrs={"data-tekton-zone": zone})
            if not zone_element:
                # Try common class patterns
                zone_class = soup.find(class_=re.compile(f"{component}.*__{zone}"))
                if zone_class:
                    validation["findings"].append({
                        "type": "missing",
                        "check": "semantic-tags",
                        "element": f"{zone}",
                        "message": f"Found .{zone_class.get('class', [''])[0]} but missing data-tekton-zone=\"{zone}\""
                    })
                    semantic_score -= 10
        
        # Check for action tags on interactive elements
        buttons = soup.find_all(['button', 'a'])
        tabs = soup.find_all(class_=re.compile(r'.*__tab'))
        interactive = buttons + tabs
        
        if interactive:
            missing_actions = 0
            for elem in interactive[:10]:  # Check first 10
                if not elem.get("data-tekton-action"):
                    missing_actions += 1
            
            if missing_actions > 0:
                validation["findings"].append({
                    "type": "missing",
                    "check": "semantic-tags",
                    "element": "interactive",
                    "message": f"{missing_actions} interactive elements missing data-tekton-action"
                })
                semantic_score -= min(15, missing_actions * 3)
        
        validation["summary"]["semantic_score"] = max(0, semantic_score)
        validation["summary"]["score"] = min(validation["summary"]["score"], semantic_score)
    
    # Check data attributes
    if "data-attributes" in checks:
        data_attrs = {}
        for element in soup.find_all():
            for attr, value in element.attrs.items():
                if attr.startswith("data-"):
                    data_attrs[attr] = data_attrs.get(attr, 0) + 1
        
        validation["summary"]["data_attributes_count"] = len(data_attrs)
        validation["summary"]["data_tekton_coverage"] = sum(1 for k in data_attrs if k.startswith("data-tekton"))
    
    # Check component structure
    if "component-structure" in checks:
        structure_score = 100
        
        # Check BEM naming
        bem_pattern = re.compile(f"^{component}(__[a-z-]+)?(--[a-z-]+)?$")
        non_bem_classes = []
        
        for element in soup.find_all(class_=True):
            for cls in element.get("class", []):
                if cls.startswith(component) and not bem_pattern.match(cls):
                    non_bem_classes.append(cls)
        
        if non_bem_classes:
            validation["findings"].append({
                "type": "warning",
                "check": "component-structure",
                "message": f"Non-BEM classes found: {', '.join(set(non_bem_classes[:5]))}"
            })
            structure_score -= 10
        
        validation["summary"]["structure_score"] = structure_score
        validation["summary"]["score"] = min(validation["summary"]["score"], structure_score)
    
    # Add recommendations
    if validation["findings"]:
        validation["recommendations"].append({
            "component": component,
            "action": "Add missing semantic tags following the instrumentation template"
        })
    
    return validation


async def _validate_navigation(page: Page, checks: List[str]) -> Dict[str, Any]:
    """Validate navigation structure"""
    validation = {
        "summary": {"score": 100},
        "findings": [],
        "recommendations": []
    }
    
    nav_data = await page.evaluate("""
        () => {
            const navItems = document.querySelectorAll('.nav-item');
            const results = [];
            
            navItems.forEach(item => {
                results.push({
                    hasDataComponent: !!item.getAttribute('data-component'),
                    hasDataTektonNavItem: !!item.getAttribute('data-tekton-nav-item'),
                    hasDataTektonState: !!item.getAttribute('data-tekton-state'),
                    component: item.getAttribute('data-component'),
                    classes: Array.from(item.classList)
                });
            });
            
            return {
                totalItems: navItems.length,
                items: results,
                hasMainNav: !!document.querySelector('[data-tekton-nav="main"]')
            };
        }
    """)
    
    if "navigation" in checks:
        nav_score = 100
        
        if not nav_data["hasMainNav"]:
            validation["findings"].append({
                "type": "missing",
                "check": "navigation",
                "message": "Main navigation missing data-tekton-nav=\"main\""
            })
            nav_score -= 20
        
        # Check each nav item
        missing_attrs = 0
        for item in nav_data["items"]:
            if not item["hasDataTektonNavItem"]:
                missing_attrs += 1
        
        if missing_attrs > 0:
            validation["findings"].append({
                "type": "missing",
                "check": "navigation",
                "message": f"{missing_attrs} nav items missing data-tekton-nav-item"
            })
            nav_score -= min(30, missing_attrs * 5)
        
        validation["summary"]["navigation_score"] = nav_score
        validation["summary"]["score"] = nav_score
        validation["summary"]["nav_items_checked"] = nav_data["totalItems"]
    
    return validation


async def ui_batch(
    area: str,
    operations: List[Dict[str, Any]],
    atomic: bool = True
) -> Dict[str, Any]:
    """
    Execute multiple UI operations in batch
    
    Args:
        area: UI area to operate on (e.g., 'hephaestus')
        operations: List of operations to perform
        atomic: If True, all operations must succeed or all are rolled back
        
    Returns:
        Result with success status and details of each operation
    """
    await browser_manager.initialize()
    page = await browser_manager.get_page()
    
    result = {
        "area": area,
        "atomic": atomic,
        "total_operations": len(operations),
        "completed": 0,
        "failed": 0,
        "operations_results": [],
        "rollback_performed": False
    }
    
    # Capture initial state if atomic mode
    initial_state = None
    if atomic:
        logger.info("Capturing initial state for atomic batch operation")
        initial_capture = await ui_capture(area=area)
        initial_state = await page.content()
    
    # Execute each operation
    for idx, operation in enumerate(operations):
        op_result = {
            "index": idx,
            "action": operation.get("action"),
            "status": "pending",
            "details": {}
        }
        
        try:
            action = operation.get("action")
            logger.info(f"Executing batch operation {idx+1}/{len(operations)}: {action}")
            
            if action == "rename":
                # Text replacement operation
                from_text = operation.get("from")
                to_text = operation.get("to")
                selector = operation.get("selector", f"*:contains('{from_text}')")
                
                change = {
                    "type": "text",
                    "selector": selector,
                    "content": to_text,
                    "action": "replace"
                }
                
                sandbox_result = await ui_sandbox(area=area, changes=[change], preview=False)
                op_result["status"] = "success" if sandbox_result.get("summary", {}).get("successful", 0) > 0 else "failed"
                op_result["details"] = sandbox_result
                
            elif action == "remove":
                # Remove element operation
                selector = operation.get("selector")
                if not selector:
                    # Build selector from component and target
                    component = operation.get("component")
                    target = operation.get("target", "emoji")
                    if target == "emoji":
                        selector = f"[data-component='{component}'] .button-icon"
                    else:
                        selector = f"[data-component='{component}'] .{target}"
                
                change = {
                    "type": "html",
                    "selector": selector,
                    "content": "",
                    "action": "replace"
                }
                
                sandbox_result = await ui_sandbox(area=area, changes=[change], preview=False)
                op_result["status"] = "success" if sandbox_result.get("summary", {}).get("successful", 0) > 0 else "failed"
                op_result["details"] = sandbox_result
                
            elif action == "add_class":
                # Add CSS class operation
                selector = operation.get("selector")
                class_name = operation.get("class")
                
                await page.evaluate(f"""
                    () => {{
                        const elements = document.querySelectorAll('{selector}');
                        elements.forEach(el => el.classList.add('{class_name}'));
                        return elements.length;
                    }}
                """)
                
                op_result["status"] = "success"
                op_result["details"]["message"] = f"Added class '{class_name}' to elements"
                
            elif action == "remove_class":
                # Remove CSS class operation
                selector = operation.get("selector")
                class_name = operation.get("class")
                
                await page.evaluate(f"""
                    () => {{
                        const elements = document.querySelectorAll('{selector}');
                        elements.forEach(el => el.classList.remove('{class_name}'));
                        return elements.length;
                    }}
                """)
                
                op_result["status"] = "success"
                op_result["details"]["message"] = f"Removed class '{class_name}' from elements"
                
            elif action == "style":
                # Apply CSS styles
                selector = operation.get("selector")
                styles = operation.get("styles", {})
                
                changes = []
                for prop, value in styles.items():
                    changes.append({
                        "type": "css",
                        "selector": selector,
                        "property": prop,
                        "value": value
                    })
                
                sandbox_result = await ui_sandbox(area=area, changes=changes, preview=False)
                op_result["status"] = "success" if sandbox_result.get("summary", {}).get("successful", 0) > 0 else "failed"
                op_result["details"] = sandbox_result
                
            elif action == "navigate":
                # Navigate to component
                component = operation.get("component")
                nav_result = await ui_navigate(component=component)
                op_result["status"] = "success" if nav_result.get("navigation_completed") else "failed"
                op_result["details"] = nav_result
                
            elif action == "click":
                # Click element
                selector = operation.get("selector")
                interact_result = await ui_interact(area=area, action="click", selector=selector)
                op_result["status"] = "success" if "error" not in interact_result else "failed"
                op_result["details"] = interact_result
                
            else:
                op_result["status"] = "failed"
                op_result["error"] = f"Unknown action: {action}"
            
            # Update counters
            if op_result["status"] == "success":
                result["completed"] += 1
            else:
                result["failed"] += 1
                
            result["operations_results"].append(op_result)
            
            # Check atomic mode failure
            if atomic and op_result["status"] == "failed":
                logger.warning(f"Atomic batch operation failed at step {idx+1}")
                break
                
        except Exception as e:
            logger.error(f"Error in batch operation {idx+1}: {e}")
            op_result["status"] = "error"
            op_result["error"] = str(e)
            result["failed"] += 1
            result["operations_results"].append(op_result)
            
            if atomic:
                break
    
    # Handle rollback if atomic and any failed
    if atomic and result["failed"] > 0 and initial_state:
        logger.info("Performing rollback due to atomic batch failure")
        try:
            # Restore initial state
            await page.set_content(initial_state)
            result["rollback_performed"] = True
            result["rollback_status"] = "success"
        except Exception as e:
            logger.error(f"Rollback failed: {e}")
            result["rollback_status"] = "failed"
            result["rollback_error"] = str(e)
    
    # Summary
    result["success"] = result["failed"] == 0
    result["summary"] = {
        "total": len(operations),
        "completed": result["completed"],
        "failed": result["failed"],
        "success_rate": f"{(result['completed'] / len(operations) * 100):.1f}%" if operations else "0%"
    }
    
    return result


async def ui_help(topic: Optional[str] = None) -> Dict[str, Any]:
    """
    Get help about UI DevTools usage
    
    Args:
        topic: Specific topic or leave empty for general help
            Valid topics: 'areas', 'selectors', 'frameworks', 'errors', 'tasks', 'architecture'
    
    Returns:
        Help information with examples and guidance
    """
    from datetime import datetime
    
    help_topics = {
        "areas": {
            "title": "Understanding UI Areas",
            "explanation": "ALL UI is in Hephaestus at port 8080. Components like Rhetor, Hermes, etc. are AREAS within the Hephaestus UI, not separate applications.",
            "key_point": "🎯 There is only ONE UI at http://localhost:8080",
            "example": """# List all available areas
areas = await ui_list_areas()

# Capture the Rhetor area within Hephaestus
result = await ui_capture('rhetor')

# Work with navigation area
nav = await ui_capture('navigation')""",
            "common_mistakes": [
                "❌ Trying to connect to port 8003 - that's Rhetor's API, not UI!",
                "❌ Looking for separate UIs for each component",
                "❌ Using 'rhetor-ui' instead of just 'rhetor'"
            ],
            "pro_tip": "Use ui_list_areas() whenever you're unsure about area names!"
        },
        
        "selectors": {
            "title": "Using CSS Selectors",
            "explanation": "CSS selectors let you target specific elements within a UI area.",
            "selector_priority": [
                "1. #specific-id - Most reliable",
                "2. .component-class - Good for groups",
                "3. [data-component='x'] - Semantic",
                "4. tag - Use sparingly"
            ],
            "example": """# Capture specific element in Rhetor
footer = await ui_capture('rhetor', '#rhetor-footer')

# Multiple selector attempts
selectors = ['#footer', '.footer', 'footer']
for sel in selectors:
    try:
        result = await ui_capture('rhetor', sel)
        break
    except:
        continue""",
            "debugging": "Use ui_capture without selector first to see what's available",
            "patterns": {
                "Tekton standard": "#component-area (e.g., #rhetor-content)",
                "Navigation": "#left-nav, .navigation",
                "Content": "#center-content, .content-area",
                "Panels": "#right-panel, .panel-right"
            }
        },
        
        "frameworks": {
            "title": "The Framework-Free Philosophy",
            "explanation": "Hephaestus UI is intentionally simple. NO frameworks allowed!",
            "casey_says": "🧓 'I'm 70 years old and I like simple things that work!'",
            "why_no_frameworks": [
                "✅ Performance - No framework overhead",
                "✅ Maintainability - Anyone can understand HTML/CSS",
                "✅ Reliability - Fewer dependencies = fewer problems",
                "✅ Casey's sanity - He really means it!"
            ],
            "alternatives": {
                "Instead of React component": "Use simple HTML: '<div class=\"widget\">Content</div>'",
                "Instead of Vue reactivity": "Use data attributes: 'data-state=\"active\"'",
                "Instead of Angular forms": "Use standard HTML forms with fetch",
                "Instead of CSS frameworks": "Use Tekton's existing styles"
            },
            "example": """# ❌ WRONG - This will be rejected!
changes = [{
    "type": "html",
    "content": '<script>import React from "react"</script>'
}]

# ✅ RIGHT - Simple and effective
changes = [{
    "type": "html",
    "content": '<div class="status">Online</div>',
    "selector": "#rhetor-header",
    "action": "append"
}]"""
        },
        
        "errors": {
            "title": "Common Errors and Solutions",
            "errors": {
                "Unknown UI area": {
                    "cause": "Using invalid area name",
                    "solution": "Run ui_list_areas() to see valid names",
                    "example": "Use 'rhetor' not 'rhetor-ui' or 'rhetor-component'"
                },
                "Selector not found": {
                    "cause": "Element doesn't exist or wrong selector",
                    "solution": "Capture area first without selector to explore",
                    "example": "await ui_capture('rhetor') # See what's there"
                },
                "Change rejected": {
                    "cause": "Framework or dangerous pattern detected",
                    "solution": "Use simple HTML/CSS only",
                    "example": "No React, Vue, Angular, webpack, npm, etc."
                },
                "Browser error": {
                    "cause": "Browser crashed or page not loaded",
                    "solution": "The browser will auto-restart, just retry",
                    "example": "await ui_capture('hephaestus') # Retry"
                }
            },
            "debugging_workflow": """1. Check area name with ui_list_areas()
2. Capture without selector to explore
3. Verify selector in captured content
4. Test with preview=True first
5. Check for framework violations"""
        },
        
        "tasks": {
            "title": "Common UI Tasks",
            "tasks": {
                "Add timestamp": {
                    "description": "Add a timestamp to any area",
                    "code": """await ui_sandbox('rhetor', [{
    'type': 'html',
    'selector': '#rhetor-footer',
    'content': f'<div class="timestamp">Updated: {datetime.now():%H:%M}</div>',
    'action': 'append'
}], preview=False)""",
                    "warning": "Don't use moment.js or date libraries!"
                },
                "Add status indicator": {
                    "description": "Show component status",
                    "code": """# HTML
status_html = '''<div id="status" class="status-indicator">
    <span class="dot"></span>
    <span class="text">Ready</span>
</div>'''

# CSS
status_css = '''.status-indicator { display: flex; align-items: center; gap: 8px; }
.dot { width: 8px; height: 8px; border-radius: 50%; background: #4CAF50; }
.dot.busy { background: #FFA726; animation: pulse 1s infinite; }'''

# Apply both
await ui_sandbox('rhetor', [
    {'type': 'html', 'selector': '#rhetor-header', 'content': status_html, 'action': 'append'},
    {'type': 'css', 'content': status_css}
], preview=False)"""
                },
                "Modify navigation": {
                    "description": "Update navigation elements",
                    "code": """# Highlight active nav item
await ui_sandbox('navigation', [{
    'type': 'css',
    'content': '.nav-item.active { background: rgba(255,255,255,0.1); }'
}], preview=True)"""
                },
                "Add notification": {
                    "description": "Show a notification",
                    "code": """notif = '''<div class="notification" style="position:fixed; top:20px; right:20px; 
    background:#333; color:white; padding:12px 20px; border-radius:8px; z-index:1000;">
    ✓ Task completed successfully
</div>'''
await ui_sandbox('hephaestus', [{
    'type': 'html', 'selector': 'body', 'content': notif, 'action': 'append'
}], preview=False)"""
                }
            }
        },
        
        "architecture": {
            "title": "Hephaestus UI Architecture",
            "mental_model": """
🏛️ HEPHAESTUS UI (Port 8080) - The Temple of UI
│
├── 🧭 Navigation Area (#left-nav)
│   └── Links to different component areas
│
├── 📋 Content Area (#center-content)
│   ├── 🤖 Rhetor Area (LLM chat interface)
│   ├── 📨 Hermes Area (Messaging system)
│   ├── 🧠 Athena Area (Knowledge base)
│   ├── 💾 Engram Area (Memory system)
│   └── ... other component areas
│
└── 📊 Panel Area (#right-panel)
    └── Contextual information and controls""",
            "key_concepts": {
                "Single UI": "Everything is at http://localhost:8080",
                "Areas not Apps": "Components are areas within Hephaestus",
                "Dynamic Loading": "Areas appear based on navigation",
                "Shared Layout": "All components use the same structure"
            },
            "port_clarification": """
Component Ports - What They Really Are:
• Port 8080 (Hephaestus) = THE UI ← You want this!
• Port 8003 (Rhetor) = API only (no UI here!)
• Port 8001 (Hermes) = API only (no UI here!)
• Port 8010 (Athena) = API only (no UI here!)

Think of it like a restaurant:
- Hephaestus (8080) is the dining room where you see everything
- Other ports are the kitchen doors (API access only)""",
            "example": """# ✅ CORRECT - All UI work happens through Hephaestus
ui_capture('rhetor')  # Gets Rhetor area from Hephaestus UI

# ❌ WRONG - These ports have no UI!
# http://localhost:8003  # No UI here!
# http://localhost:8001  # No UI here!"""
        }
    }
    
    # If specific topic requested
    if topic and topic.lower() in help_topics:
        return help_topics[topic.lower()]
    
    # General help overview
    return {
        "welcome": "🛠️ Welcome to Hephaestus UI DevTools Help!",
        "version": "v2.0 (The one that actually works correctly)",
        "golden_rules": [
            "🎯 Rule 1: ALL UI is at http://localhost:8080",
            "🚫 Rule 2: NO frameworks (React, Vue, Angular, etc.)",
            "✅ Rule 3: Simple HTML/CSS is always the answer",
            "🔍 Rule 4: Use ui_list_areas() when confused",
            "🧪 Rule 5: Always preview=True before preview=False"
        ],
        "quick_start": """
# 1. See what areas are available
areas = await ui_list_areas()

# 2. Navigate to a component
await ui_navigate('rhetor')

# 3. Capture the area to explore it
rhetor = await ui_capture('rhetor')

# 4. Make a simple change (preview first!)
await ui_sandbox('rhetor', [{
    'type': 'html',
    'selector': '#rhetor-footer',
    'content': '<div>Hello from DevTools!</div>',
    'action': 'append'
}], preview=True)

# 5. Apply if it looks good
await ui_sandbox('rhetor', [...], preview=False)
""",
        "available_tools": {
            "ui_list_areas()": "Discover all UI areas in Hephaestus",
            "ui_navigate(component)": "Navigate to a component by clicking its nav item",
            "ui_capture(area, selector?)": "Look at UI structure without screenshots",
            "ui_sandbox(area, changes, preview)": "Safely test UI modifications", 
            "ui_interact(area, action, selector, value?)": "Click, type, select elements",
            "ui_analyze(area)": "Check for frameworks and complexity",
            "ui_help(topic?)": "This help system!"
        },
        "help_topics": {
            "areas": "Understanding UI areas vs components",
            "selectors": "How to target specific elements",
            "frameworks": "Why we don't use them (and what to do instead)",
            "errors": "Common errors and how to fix them",
            "tasks": "Code examples for common UI tasks",
            "architecture": "The big picture of Hephaestus UI"
        },
        "pro_tips": [
            "💡 Confused about ports? Remember: 8080 is the ONLY UI port",
            "💡 Can't find an element? Capture without selector first",
            "💡 Change rejected? You probably tried to add a framework",
            "💡 Need to modify Rhetor? It's an area IN Hephaestus, not separate"
        ],
        "casey_quote": "🧓 'Keep it simple. If you're thinking about npm install, you're thinking wrong!'",
        "get_specific_help": "Call ui_help('topic') for detailed help. Topics: " + ", ".join(help_topics.keys())
    }


# Export functions for MCP registration
__all__ = [
    "ui_list_areas",
    "ui_recommend_approach",  # Phase 1: Intelligent routing
    "ui_capture",
    "ui_navigate",
    "ui_interact", 
    "ui_sandbox",
    "ui_analyze",
    "ui_validate",
    "ui_help",
    "browser_manager"
]