#!/usr/bin/env python3
"""
aish-proxy - AI-enhanced shell using safe shell hooks

This provides AI capabilities through shell functions/aliases
without any dangerous terminal manipulation.

Usage:
  ./aish-proxy              # Interactive mode
  ./aish-proxy -c "cmd"     # Single command (not supported yet)
"""

import sys
import os
from pathlib import Path

# Get the directory containing this script
script_dir = Path(__file__).resolve().parent
src_path = script_dir / 'src'

# Add src to Python path
sys.path.insert(0, str(src_path))

import subprocess
import tempfile
import threading
import time
import json
import urllib.request
import urllib.error


def start_heartbeat_daemon():
    """Start background thread to send heartbeats to Terma."""
    terma_session_id = os.environ.get('TERMA_SESSION_ID')
    terma_endpoint = os.environ.get('TERMA_ENDPOINT', 'http://localhost:8004')
    
    if not terma_session_id:
        # Not launched by Terma, no heartbeats needed
        return None, None
    
    # Import queue for thread-safe command handling
    import queue
    
    # Flag to stop heartbeat thread
    stop_heartbeat = threading.Event()
    
    # Queue for pending command results
    pending_results = []
    result_lock = threading.Lock()
    
    def send_heartbeat(status="active", immediate=False):
        """Send a single heartbeat."""
        try:
            heartbeat_data = {
                "terma_id": terma_session_id,
                "pid": os.getpid(),
                "name": os.environ.get('TERMA_TERMINAL_NAME', 'aish Terminal'),
                "working_dir": os.getcwd(),
                "terminal_app": os.environ.get('TERM_PROGRAM', 'unknown'),
                "aish_version": "3.0.0",
                "timestamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                "status": status
            }
            
            # Include any pending command results
            with result_lock:
                if pending_results:
                    heartbeat_data["command_results"] = pending_results[:]
                    pending_results.clear()
            
            # Send heartbeat
            url = f"{terma_endpoint}/api/mcp/v2/terminals/heartbeat"
            data = json.dumps(heartbeat_data).encode('utf-8')
            req = urllib.request.Request(url, data=data, 
                                       headers={'Content-Type': 'application/json'})
            
            try:
                with urllib.request.urlopen(req, timeout=5) as response:
                    response_data = response.read()
                    if response_data:
                        result = json.loads(response_data)
                        # Check for commands to execute
                        if "commands" in result and result["commands"]:
                            for cmd in result["commands"]:
                                execute_command(cmd)
            except urllib.error.URLError:
                # Terma might be down, that's ok
                pass
                
        except Exception:
            # Don't let heartbeat errors crash the shell
            pass
    
    def execute_command(cmd_info):
        """Execute a command and queue the result."""
        try:
            # Execute command in subprocess
            result = subprocess.run(
                cmd_info["command"],
                shell=True,
                capture_output=True,
                text=True,
                timeout=10,
                cwd=os.getcwd()
            )
            
            cmd_result = {
                "id": cmd_info["id"],
                "output": result.stdout or result.stderr,
                "error": result.stderr if result.returncode != 0 else None,
                "exit_code": result.returncode
            }
            
            # Queue result and trigger immediate heartbeat
            with result_lock:
                pending_results.append(cmd_result)
            
            # Send immediate heartbeat with result
            send_heartbeat("active", immediate=True)
            
        except subprocess.TimeoutExpired:
            with result_lock:
                pending_results.append({
                    "id": cmd_info["id"],
                    "output": "",
                    "error": "Command timed out after 10 seconds",
                    "exit_code": -1
                })
            send_heartbeat("active", immediate=True)
        except Exception as e:
            with result_lock:
                pending_results.append({
                    "id": cmd_info["id"],
                    "output": "",
                    "error": str(e),
                    "exit_code": -1
                })
            send_heartbeat("active", immediate=True)
    
    def send_heartbeats():
        """Send heartbeat every 30 seconds, check for commands every 0.5 seconds."""
        last_heartbeat = time.time()
        last_command_check = time.time()
        
        while not stop_heartbeat.is_set():
            # Check for commands frequently (every 2 seconds)
            if time.time() - last_command_check >= 2:
                # Send a heartbeat to check for commands
                send_heartbeat("active")
                last_command_check = time.time()
                last_heartbeat = time.time()  # This counts as a heartbeat too
            # Send regular heartbeat if time
            elif time.time() - last_heartbeat >= 30:
                send_heartbeat("active")
                last_heartbeat = time.time()
            
            # Short sleep to be responsive
            time.sleep(0.5)
    
    # Start heartbeat thread as daemon so it exits when main process exits
    heartbeat_thread = threading.Thread(target=send_heartbeats, daemon=True)
    heartbeat_thread.start()
    print(f"aish heartbeat started (session: {terma_session_id[:8]}...)")
    
    # Return the send_heartbeat function and stop event for exit handler
    return send_heartbeat, stop_heartbeat


def create_shell_init(shell_name, aish_dir, rhetor_endpoint=None, debug=False):
    """Create shell initialization for AI commands."""
    rhetor = rhetor_endpoint or "http://localhost:8003"
    
    # Base functions that work in both bash and zsh
    common_functions = f'''
# aish proxy initialization
export AISH_ACTIVE=1
export AISH_VERSION="3.0.0"
export RHETOR_ENDPOINT="{rhetor}"

# Ensure aish command is in PATH
export PATH="{aish_dir}:$PATH"

# That's it! The 'aish' command will handle all AI routing
# Usage:
#   aish apollo "query"
#   echo "data" | aish athena
#   aish team-chat "message"
'''
    
    # No shell-specific code needed anymore - just use aish command
    init_content = common_functions
    
    if not debug:
        init_content += '''
echo "aish-proxy active (v3.0.0) - Usage: aish <ai-name> [message]"
echo "Examples: aish apollo | aish team-chat 'hello' | echo 'test' | aish athena"
'''
    
    return init_content

def main():
    """Main entry point for aish proxy."""
    import argparse
    import atexit
    import signal
    
    parser = argparse.ArgumentParser(
        description='aish-proxy - Safe AI-enhanced shell',
        epilog='Provides AI capabilities through shell functions'
    )
    
    parser.add_argument(
        '-c', '--command',
        help='Single command mode not supported yet'
    )
    
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Enable debug output'
    )
    
    parser.add_argument(
        '--shell',
        help='Base shell to use (default: $SHELL)',
        default=None
    )
    
    parser.add_argument(
        '--rhetor',
        help='Rhetor endpoint (default: http://localhost:8003)',
        default=None
    )
    
    parser.add_argument(
        '--version',
        action='store_true',
        help='Show version and exit'
    )
    
    args = parser.parse_args()
    
    if args.version:
        print("aish-proxy v3.0.0 - Safe shell hook implementation")
        return 0
    
    if args.command:
        print("Error: Single command mode not implemented yet", file=sys.stderr)
        return 1
    
    # Determine shell
    shell = args.shell or os.environ.get('SHELL', '/bin/bash')
    shell_name = os.path.basename(shell)
    
    # Get aish directory
    aish_dir = str(Path(__file__).resolve().parent)
    
    # Create initialization
    init_content = create_shell_init(shell_name, aish_dir, args.rhetor, args.debug)
    
    # Write to temp file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.sh', delete=False) as f:
        f.write(init_content)
        init_file = f.name
    
    try:
        # Start heartbeat daemon if launched by Terma
        send_heartbeat_func, stop_event = start_heartbeat_daemon()
        
        # If we have heartbeat, register exit handler
        if send_heartbeat_func:
            def cleanup_and_exit():
                """Stop heartbeat, send goodbye, and exit cleanly."""
                # Stop the heartbeat thread first
                if stop_event:
                    stop_event.set()
                # Send final terminated heartbeat
                send_heartbeat_func("terminated")
                # Give it a moment to send
                time.sleep(0.1)
            
            # Register cleanup for normal exit
            atexit.register(cleanup_and_exit)
            
            # Also handle signals
            def signal_handler(signum, frame):
                cleanup_and_exit()
                sys.exit(0)
            
            for sig in [signal.SIGTERM, signal.SIGINT]:
                signal.signal(sig, signal_handler)
        
        if 'zsh' in shell_name:
            # For zsh, source our file then run interactive shell
            cmd = [shell, '-c', f'source {init_file} && exec {shell} -i']
        else:
            # For bash, use --rcfile
            cmd = [shell, '--rcfile', init_file]
        
        # Run the shell
        result = subprocess.run(cmd)
        return result.returncode
        
    finally:
        # Cleanup
        try:
            os.unlink(init_file)
        except:
            pass
    
    return 0


if __name__ == "__main__":
    sys.exit(main())