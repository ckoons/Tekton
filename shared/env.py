"""
Tekton Environment Management

Provides controlled environment configuration loading and access.
Only the main tekton script should use TektonEnvironLock.
All other modules should use TektonEnviron.
"""
import os
import logging
from pathlib import Path
from typing import Dict, Any, Optional
from datetime import datetime

# Module-level storage for frozen environment
_frozen_env: Dict[str, str] = {}
_is_loaded: bool = False

# Setup logging
logger = logging.getLogger(__name__)


class TektonEnvironLock:
    """
    Environment loader - ONLY for use by main tekton script.
    Loads environment files in correct order and freezes the result.
    """
    
    @staticmethod
    def load() -> None:
        """
        Load environment from multiple sources in order:
        1. Current os.environ
        2. ~/.env
        3. $TEKTON_ROOT/.env.tekton
        4. $TEKTON_ROOT/.env.local
        
        Each file overwrites values from previous sources.
        Updates both os.environ and the frozen copy.
        """
        global _frozen_env, _is_loaded
        
        if _is_loaded:
            logger.warning("TektonEnvironLock.load() called multiple times - ignoring")
            return
        
        # Start with current environment
        env_dict = dict(os.environ)
        
        # TEKTON_ROOT must already be set in environment
        # (the main scripts run from any directory and must have it set)
        if 'TEKTON_ROOT' not in env_dict:
            raise RuntimeError("TEKTON_ROOT not set in environment")
        
        # Load files in order
        env_files = [
            Path.home() / '.env',
            Path(env_dict.get('TEKTON_ROOT', '')) / '.env.tekton',
            Path(env_dict.get('TEKTON_ROOT', '')) / '.env.local'
        ]
        
        for env_file in env_files:
            if env_file.exists():
                logger.debug(f"Loading environment from: {env_file}")
                _load_env_file(env_file, env_dict)
        
        # Set internal system variable to indicate environment is frozen
        # This allows subprocesses to detect they have the frozen environment
        env_dict['_TEKTON_ENV_FROZEN'] = '1'
        
        # Update os.environ with the merged result
        os.environ.clear()
        os.environ.update(env_dict)
        
        # Freeze a copy for TektonEnviron
        _frozen_env = dict(env_dict)
        _is_loaded = True
        
        # Write JavaScript environment file for Hephaestus UI
        TektonEnvironLock._write_javascript_env(env_dict)
        
        logger.info(f"Environment loaded and frozen with {len(_frozen_env)} variables")
    
    @staticmethod
    def _write_javascript_env(env_dict: Dict[str, str]) -> None:
        """
        Write JavaScript env.js file with actual port values from environment.
        This ensures the Hephaestus UI always has the correct port configuration.
        """
        # Get TEKTON_ROOT to find the env.js file
        tekton_root = env_dict.get('TEKTON_ROOT')
        if not tekton_root:
            logger.warning("TEKTON_ROOT not set, cannot write JavaScript env file")
            return
            
        # Build the JavaScript content with actual port values
        js_content = f"""/**
 * Environment variables for Tekton UI
 * AUTO-GENERATED by TektonEnvironLock - DO NOT EDIT MANUALLY
 * Generated at: {datetime.now().isoformat()}
 * 
 * This file is automatically regenerated when Tekton starts.
 * Port values are read from the environment configuration.
 */

console.log('[FILE_TRACE] Loading: env.js');

// Single Port Architecture environment variables - from actual environment
window.HEPHAESTUS_PORT = {env_dict.get('HEPHAESTUS_PORT', '8080')};  // Hephaestus port
window.ENGRAM_PORT = {env_dict.get('ENGRAM_PORT', '8000')};      // Engram port
window.HERMES_PORT = {env_dict.get('HERMES_PORT', '8001')};      // Hermes port
window.ERGON_PORT = {env_dict.get('ERGON_PORT', '8002')};       // Ergon port
window.RHETOR_PORT = {env_dict.get('RHETOR_PORT', '8003')};      // Rhetor port
window.TERMA_PORT = {env_dict.get('TERMA_PORT', '8004')};       // Terma port
window.ATHENA_PORT = {env_dict.get('ATHENA_PORT', '8005')};      // Athena port
window.PROMETHEUS_PORT = {env_dict.get('PROMETHEUS_PORT', '8006')};  // Prometheus port
window.HARMONIA_PORT = {env_dict.get('HARMONIA_PORT', '8007')};    // Harmonia port
window.TELOS_PORT = {env_dict.get('TELOS_PORT', '8008')};       // Telos port
window.SYNTHESIS_PORT = {env_dict.get('SYNTHESIS_PORT', '8009')};   // Synthesis port
window.TEKTON_CORE_PORT = {env_dict.get('TEKTON_CORE_PORT', '8010')}; // Tekton Core port
window.METIS_PORT = {env_dict.get('METIS_PORT', '8011')};       // Metis port
window.APOLLO_PORT = {env_dict.get('APOLLO_PORT', '8012')};      // Apollo port
window.BUDGET_PORT = {env_dict.get('BUDGET_PORT', '8013')};      // Budget port
window.PENIA_PORT = {env_dict.get('PENIA_PORT', '8013')};       // Penia port (same as budget)
window.SOPHIA_PORT = {env_dict.get('SOPHIA_PORT', '8014')};      // Sophia port
window.NOESIS_PORT = {env_dict.get('NOESIS_PORT', '8015')};      // Noesis port
window.NUMA_PORT = {env_dict.get('NUMA_PORT', '8016')};        // Numa port

// Debug settings
window.TEKTON_DEBUG = '{env_dict.get('TEKTON_DEBUG', 'true')}';        // Master switch for debug instrumentation
window.TEKTON_LOG_LEVEL = '{env_dict.get('TEKTON_LOG_LEVEL', 'DEBUG')}';   // Default log level

// Mark that ports are from environment, not defaults
window.PORTS_FROM_ENV = true;
window.TEKTON_ENV_TIMESTAMP = '{datetime.now().isoformat()}';

// Function to update port values from server - NO LONGER NEEDED
function updatePortsFromServer() {{
    console.log('[ENV] updatePortsFromServer called but ports already loaded from environment');
    console.log('[ENV] TERMA_PORT =', window.TERMA_PORT);
    console.log('[ENV] Ports were loaded at:', window.TEKTON_ENV_TIMESTAMP);
    
    // Still dispatch event for compatibility
    window.dispatchEvent(new CustomEvent('ports-updated'));
}}

// No need to wait for DOMContentLoaded - ports are already correct
console.log('[ENV] Loaded port configuration from TektonEnvironLock');
console.log('[ENV] TERMA_PORT =', window.TERMA_PORT);
console.log('[ENV] HERMES_PORT =', window.HERMES_PORT);
console.log('[ENV] Environment timestamp:', window.TEKTON_ENV_TIMESTAMP);
"""
        
        # Write the file
        try:
            env_js_path = Path(tekton_root) / 'Hephaestus' / 'ui' / 'scripts' / 'env.js'
            env_js_path.parent.mkdir(parents=True, exist_ok=True)
            env_js_path.write_text(js_content)
            logger.info(f"Wrote JavaScript environment file: {env_js_path}")
        except Exception as e:
            logger.error(f"Failed to write JavaScript env file: {e}")


class TektonEnviron:
    """
    Read-only environment access for all Tekton modules.
    Provides the frozen environment state.
    
    The environment must be loaded by TektonEnvironLock.load() before use.
    This is typically done by the main tekton script. Secondary scripts
    (like tekton-status, tekton-launch) should check is_loaded() first
    and redirect users to the main tekton command if not loaded.
    
    Module state:
        _is_loaded: Boolean flag indicating if environment has been loaded
        _frozen_env: Dictionary containing the frozen environment state
    """
    
    @staticmethod
    def all() -> Dict[str, str]:
        """
        Get a copy of the entire frozen environment.
        
        Usage:
            import os
            from shared.env import TektonEnviron
            os.environ = TektonEnviron.all()
        """
        if not _is_loaded and os.environ.get('_TEKTON_ENV_FROZEN') != '1':
            # If accessed before load AND not in a subprocess with frozen env
            logger.warning("TektonEnviron accessed before TektonEnvironLock.load() - returning current os.environ")
        return dict(os.environ)  # Always return current environment
    
    @staticmethod
    def get(key: str, default: Optional[str] = None) -> Optional[str]:
        """Get a single environment variable."""
        if not _is_loaded and os.environ.get('_TEKTON_ENV_FROZEN') != '1':
            # If accessed before load AND not in a subprocess with frozen env
            logger.warning(f"TektonEnviron.get('{key}') called before TektonEnvironLock.load()")
        return os.environ.get(key, default)  # Always use current environment
    
    @staticmethod
    def set(key: str, value: str) -> None:
        """
        No-op setter that logs attempts to modify environment.
        This helps identify code that tries to change environment.
        """
        logger.debug(f"Attempted environment change ignored: {key}={value}")
    
    @staticmethod
    def is_loaded() -> bool:
        """
        Check if environment has been loaded by TektonEnvironLock.
        
        This checks both the in-memory flag (for the current process) and
        the _TEKTON_ENV_FROZEN environment variable (for subprocesses that
        received the frozen environment).
        
        Returns:
            True if environment has been loaded and frozen, False otherwise
        """
        return _is_loaded or os.environ.get('_TEKTON_ENV_FROZEN') == '1'


class TektonEnvironUpdate:
    """
    Hidden environment updater - DO NOT USE without careful review.
    This class is intentionally not exposed in normal imports.
    """
    
    @staticmethod
    def update(key: str, value: str) -> None:
        """Actually update the frozen environment - use with extreme caution."""
        global _frozen_env
        if not _is_loaded:
            raise RuntimeError("Cannot update environment before TektonEnvironLock.load()")
        
        logger.warning(f"TektonEnvironUpdate: Modifying frozen environment {key}={value}")
        _frozen_env[key] = value
        # Also update os.environ to maintain consistency
        os.environ[key] = value



def _load_env_file(filepath: Path, env_dict: Dict[str, str]) -> None:
    """Load a .env file and update the environment dictionary."""
    try:
        with open(filepath, 'r') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue
                
                # Skip lines without '='
                if '=' not in line:
                    continue
                
                # Parse key=value
                key, value = line.split('=', 1)
                key = key.strip()
                value = value.strip()
                
                # Remove quotes if present
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                elif value.startswith("'") and value.endswith("'"):
                    value = value[1:-1]
                
                # Update the dictionary
                env_dict[key] = value
                logger.debug(f"  Set {key} from {filepath.name}")
                
    except Exception as e:
        logger.error(f"Error loading {filepath}: {e}")